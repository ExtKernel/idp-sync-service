package com.iliauni.idpsyncservice.idp;

import com.iliauni.idpsyncservice.model.Client;
import com.iliauni.idpsyncservice.model.User;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

/**
 * An abstract class implementing {@link UserIdpSyncHandler} for synchronizing users
 * in an Identity Provider (IDP) context.
 * The class itself is abstract because it can't operate without a specific client type
 * due to the issue of autowiring generic classes.
 * A client type is supposed to be specified concretely while inheriting!!!
 * Do not use a <T extend SomeClass> or any other generic format,
 * while inheriting as a non-abstract class. There's just no point in doing that.
 *
 * @param <T> an IDP client type. Defines synchronization specifics.
 */
public abstract class GenericUserIdpSyncHandler<T extends Client> implements UserIdpSyncHandler<T> {
    private final IdpUserManager<T> userManager;

    protected GenericUserIdpSyncHandler(IdpUserManager<T> userManager) {
        this.userManager = userManager;
    }

    @Override
    public void sync(
            T client,
            Map<String, List<User>> differenceMap
    ) {
        buildSyncFlagsMap().forEach((entryKey, value) -> {
            Boolean isNew = value[0];

            forceUserChangesOnIdp(
                    client,
                    differenceMap.getOrDefault(entryKey, new ArrayList<>()),
                    isNew
            );
        });
    }

    /**
     * Forces(makes) the changes on the IDP client using UserService.
     *
     * @param users a list of users, which are, basically, the change to be made.
     * @param isNew if true, users will be created.
     *             If false, users will be deleted.
     */
    private void forceUserChangesOnIdp(
            T client,
            List<User> users,
            boolean isNew
    ) {
        List<CompletableFuture<User>> futures = new ArrayList<>();
        List<CompletableFuture<Void>> voidFutures = new ArrayList<>();

        users.parallelStream().forEach(user -> {
            if (isNew) {
                CompletableFuture<User> future = CompletableFuture.supplyAsync(() -> userManager.createUser(
                        client,
                        user,
                        false // DEBUG ARG. SHOULD BE TRUE
                ));
                futures.add(future);
            } else {
                CompletableFuture<Void> future = CompletableFuture.runAsync(() -> userManager.deleteUser(
                        client,
                        user.getUsername(),
                        true
                ));
                voidFutures.add(future);
            }
        });

        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
        CompletableFuture.allOf(voidFutures.toArray(new CompletableFuture[0])).join();
    }

    /**
     * Builds a map containing boolean representations of flags,
     * which are supposed to be passed to synchronization methods.
     * Such as "new", "altered", "missing", etc.
     * The keys are meant to match the keys of difference map, generated by DifferenceCalculator.
     * This exists for the sake of reducing boilerplate and adding some scalability.
     *
     * @return a map of boolean representations of DifferenceCalculator map's flags
     */
    private Map<String, Boolean[]> buildSyncFlagsMap() {
        return Map.of(
                "new", new Boolean[]{true, false},
                "missing", new Boolean[]{false, false}
        );
    }
}
